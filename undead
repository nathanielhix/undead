#!/usr/bin/env python3

from argparse import ArgumentParser
from json import dumps
from platform import system
from shutil import which
from subprocess import run, PIPE
from sys import argv, exit, stderr
from typing import Union


class NetObj:
    def __init__(self, hostname):
        self.hostname = hostname
        self.ip_addr = None
        self.status_icmp = None
        self.returncode_icmp = None
        self.net_ib = None
        self.net_oob = None
        self.outs = None
        self.errs = None


def conf_args():
    parser = ArgumentParser()

    # Required, and mutually exclusive, arguments.
    req_args = parser.add_mutually_exclusive_group(required=True)

    # Optional arguments.
    opt_args = parser.add_argument_group(title="Optional Arguments")

    req_args.add_argument(
        '-H',
        '--host-file',
        type=str,
        help='A newline separated file of DNS-resolvable hostnames.',
    )
    req_args.add_argument(
        '-n',
        '--node',
        nargs='+',
        help='A space separate list of DNS-resolvable hostnames.',
    )

    opt_args.add_argument(
        '-i',
        '--icmp',
        action='store_true',
        help='ICMP Ping targets. Calls system ping utility.',
    )
    opt_args.add_argument(
        '-t',
        '--tcp',
        type=int,
        nargs=1,
        help='TCP ping targets. Accepts a numeric port.',
    )
    opt_args.add_argument(
        '-m',
        '--monitor',
        type=int,
        const=10,
        nargs='?',
        help='Monitor mode with a polling interval in seconds. Defaults to 10.',
    )

    return parser.parse_args()


def print_fmt(msg: str, level: str) -> str:
    # Print an ANSI color wrapped string.
    colors = {
        'debug': '\033[0;36m',
        'info': '\033[0;32m',
        'warn': '\033[1;33m',
        'error': '\033[1;31m',
        'fatal': '\033[0;31m',
        'reset': '\033[0m',
    }

    if level in colors.keys():
        print(f'{colors[level]}{msg}{colors["reset"]}', file=stderr)
    else:
        print(msg)


def read_file(file: str) -> list[str]:
    # Read a file. Return a list of strings.
    try:
        with open(file, 'r') as f:
            return f.read().splitlines()
    except Exception as e:
        print_fmt(f'Failed to read from {e.filename}: {e.strerror}', 'fatal')
        exit(e.errno)


def get_prog_path(prog: str) -> str:
    # Return an absolute path to a script or binary.
    return which(prog)


def get_os() -> str:
    # Return the OS family.
    return system()


def check_ping(node: NetObj, base_cmd: list[str], os: str) -> NetObj:
    # Ping check a NetObj.
    cmd = base_cmd + [node.hostname]

    result = run(cmd, capture_output=True, encoding='UTF-8')
    node.outs = result.stdout.strip()
    node.errs = result.stderr.strip()

    if result.returncode != 0 or 'host unreachable' in node.errs.lower():
        node.status_icmp = 'unreachable'
    else:
        node.status_icmp = 'reachable'

    node.returncode_icmp = result.returncode

    return node


def main():
    args = conf_args()

    if args.node:
        nodes = args.node
    elif args.host_file:
        nodes = read_file(args.host_file)
    else:
        print_fmt(f'DEBUG: No nodes specified. Argparse should have prevented this.', 'debug')
        exit(200)

    # Build a list of nodes as NetObj.
    nodes = [NetObj(node) for node in nodes]

    if args.icmp:
        ping = get_prog_path('ping')
        os = get_os()

        if os in ['Darwin', 'Linux']:
            base_cmd = [ping, '-c', '1', '-W', '1']
        elif os == 'Windows':
            base_cmd = [ping, '/n', '1', '/w', '1000']
        else:
            base_cmd = [ping, '-c', '1', '-W', '1']

        for node in nodes:
            check_ping(node, base_cmd, os)
            print(dumps(node.__dict__, indent=2))


if __name__ == '__main__':
    exit(main())
