#!/usr/bin/env python3

from argparse import ArgumentParser
from platform import system
from shutil import which
from subprocess import run, PIPE
from sys import exit, argv
from typing import Union


def conf_args():
    parser = ArgumentParser()

    # Required, and mutually exclusive, arguments.
    req_args = parser.add_mutually_exclusive_group(required=True)

    # Optional arguments.
    opt_args = parser.add_argument_group(title="Optional Arguments")

    req_args.add_argument(
        '-H',
        '--host-file',
        type=str,
        help='A newline separated list of DNS-resolvable hostnames.',
    )
    req_args.add_argument(
        '-n',
        '--node',
        nargs='+',
        help='A space separate list of DNS-resolvable hostnames.',
    )

    opt_args.add_argument(
        '-i',
        '--icmp',
        action='store_true',
        help='ICMP Ping targets. Calls system ping utility.',
    )
    opt_args.add_argument(
        '-t',
        '--tcp',
        type=int,
        nargs=1,
        help='TCP ping targets. Accepts a numeric port.',
    )
    opt_args.add_argument(
        '-m',
        '--monitor',
        type=int,
        const=10,
        nargs='?',
        help='Monitor mode with a polling interval in seconds. Defaults to 10.',
    )

    return parser.parse_args()


def print_fmt(msg: str, level: str) -> str:
    # Print an ANSI color wrapped string.
    colors = {
        'debug': '\033[0;36m',
        'info': '\033[0;32m',
        'warn': '\033[1;33m',
        'error': '\033[1;31m',
        'fatal': '\033[0;31m',
        'reset': '\033[0m',
    }

    if level in colors.keys():
        print(f'{colors[level]}{msg}{colors["reset"]}')
    else:
        print(msg)


def read_file(file: str) -> list[str]:
    # Read a file. Return a list of strings.
    try:
        with open(file, 'r') as f:
            return f.read().splitlines()
    except Exception as e:
        print_fmt(f'Failed to read from {e.filename}: {e.strerror}', 'fatal')
        exit(e.errno)


def get_prog_path(prog: str) -> str:
    # Return an absolute path to a script or binary.
    return which(prog)


def get_os() -> str:
    # Return the OS family.
    return system()


def check_ping(addr: str, cmd: list[str], os: str) -> (bool, int, str):
    # Return true or false.
    # Extra parsing required for Windows.
    cmd.append(addr)
    result = run(cmd, capture_output=True, encoding='UTF-8')
    errs = result.stderr.strip()

    if result.returncode != 0 or 'Destination Host Unreachable' in errs:
        return False, result.returncode, errs

    return True, result.returncode, errs




def main():
    args = conf_args()

    if args.node:
        nodes = args.node
    elif args.host_file:
        nodes = read_file(args.host_file)
    else:
        print_fmt(f'DEBUG: No nodes specified. Argparse should have prevented this.', 'debug')
        exit(200)

    if args.icmp:
        ping = get_prog_path('ping')
        os = get_os()

        if os in ['Darwin', 'Linux']:
            cmd = [ping, '-c', '1', '-W', '1']
        elif os == 'Windows':
            cmd = [ping, '/n', '1', '/w', '1000']
        else:
            cmd = [ping, '-c', '1', '-W', '1']

        for node in nodes:
            print(check_ping(node, cmd, os))


if __name__ == '__main__':
    exit(main())
