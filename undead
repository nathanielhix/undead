#!/usr/bin/env python3

import concurrent.futures
from argparse import ArgumentParser
from json import dumps
from multiprocessing import cpu_count
from platform import system
from shutil import which
from subprocess import run, PIPE
from sys import argv, exit, stderr
from typing import Union


class NetObj:
    def __init__(self, hostname):
        self.hostname = hostname
        self.ip_addr = None
        self.status_icmp = None
        self.returncode_icmp = None
        self.net_ib = None
        self.net_oob = None
        self.outs = None
        self.errs = None


def conf_args():
    parser = ArgumentParser()

    # Required, and mutually exclusive, arguments.
    req_args = parser.add_mutually_exclusive_group(required=True)

    # Optional arguments.
    opt_args = parser.add_argument_group(title="Optional Arguments")


    req_args.add_argument(
        '-H',
        '--host-file',
        type=str,
        help='A newline separated file of DNS-resolvable hostnames.',
    )
    req_args.add_argument(
        '-n',
        '--node',
        nargs='+',
        help='A space separate list of DNS-resolvable hostnames.',
    )

    opt_args.add_argument(
        '-i',
        '--icmp',
        action='store_true',
        help='ICMP Ping targets. Calls system ping utility.',
    )
    opt_args.add_argument(
        '-t',
        '--tcp',
        type=int,
        nargs=1,
        help='TCP ping targets. Accepts a numeric port.',
    )
    opt_args.add_argument(
        '-m',
        '--monitor',
        type=int,
        const=10,
        nargs='?',
        help='Monitor mode with a polling interval in seconds. Defaults to 10.',
    )

    return parser.parse_args()


def print_fmt(msg: str, level: str) -> str:
    # Print an ANSI color wrapped string.
    colors = {
        'debug': '\033[0;36m',
        'info': '\033[0;32m',
        'warn': '\033[1;33m',
        'error': '\033[1;31m',
        'fatal': '\033[0;31m',
        'reset': '\033[0m',
    }

    if level in colors.keys():
        print(f'{colors[level]}{msg}{colors["reset"]}', file=stderr)
    else:
        print(msg)


def read_file(file: str) -> list[str]:
    # Read a file. Return a list of strings.
    try:
        with open(file, 'r') as f:
            return f.read().splitlines()
    except Exception as e:
        print_fmt(f'Failed to read from {e.filename}: {e.strerror}', 'fatal')
        exit(e.errno)


def get_prog_path(prog: str) -> str:
    # Return an absolute path to a script or binary.
    return which(prog)


def get_os() -> str:
    # Return the OS family.
    return system()


def get_cores() -> int:
    # Return the number of CPU cores.
    return cpu_count()


def check_ping(node: NetObj, base_cmd: list[str]) -> NetObj:
    # Ping check a NetObj.
    if type(base_cmd) is tuple:
        base_cmd = base_cmd[0]

    cmd = base_cmd + [node.hostname]

    result = run(cmd, capture_output=True, encoding='UTF-8')
    node.outs = result.stdout.strip()
    node.errs = result.stderr.strip()

    if result.returncode != 0 or 'host unreachable' in node.errs.lower():
        node.status_icmp = 'unreachable'
    else:
        node.status_icmp = 'reachable'

    node.returncode_icmp = result.returncode

    return node


def process_list(lst, func, procs, *args):
    # Concurrently run a function on a list, using ThreadPoolExecutor.
    with concurrent.futures.ThreadPoolExecutor(max_workers=procs) as executor:
        future_to_item = {executor.submit(func, item, args): item for item in lst}
        for future in concurrent.futures.as_completed(future_to_item):
            item = future_to_item[future]

            try:
                data = future.result()
            except Exception as e:
                print('%r generated an exception: %s' % (item, e))
            #else:
            #    print('%r page is %d bytes' % (item, len(data.__dict__)))

    return lst


def main():
    args = conf_args()

    if args.node:
        nodes = args.node
    elif args.host_file:
        nodes = read_file(args.host_file)
    else:
        print_fmt(f'DEBUG: No nodes specified. Argparse should have prevented this.', 'debug')
        exit(200)

    # Build a list of nodes as NetObj.
    nodes = [NetObj(node) for node in nodes]

    if args.icmp:
        ping = get_prog_path('ping')
        os = get_os()
        cores = get_cores()

        # Performance test.
        cores = cores * 6

        if os in ['Darwin', 'Linux']:
            base_cmd = [ping, '-c', '1', '-W', '1']
        elif os == 'Windows':
            base_cmd = [ping, '/n', '1', '/w', '1000']
        else:
            base_cmd = [ping, '-c', '1', '-W', '1']

        nodes = process_list(nodes, check_ping, cores, base_cmd)

        for node in nodes:
            print(dumps(node.__dict__, indent=2))


if __name__ == '__main__':
    exit(main())
