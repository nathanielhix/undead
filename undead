#!/usr/bin/env python3

from argparse import ArgumentParser
from collections.abc import Callable
from concurrent.futures import ThreadPoolExecutor, as_completed
from csv import DictWriter
from datetime import datetime
from ipaddress import ip_address, ip_network
from json import dump
from multiprocessing import cpu_count
from platform import system
from socket import AF_INET, gaierror, getaddrinfo
from shutil import which
from subprocess import run, PIPE
from sys import argv, exit, stderr
from typing import Any, Union


class NetObj:
    def __init__(self, hostname):
        self.hostname = hostname
        self.ip_addr = None
        self.status = None
        self.return_code = None
        self.net_ib = None
        self.net_oob = None
        self.outs = None
        self.errs = None


def conf_args():
    parser = ArgumentParser()

    # Required, and mutually exclusive, arguments.
    req_args = parser.add_mutually_exclusive_group(required=True)

    # Optional arguments.
    opt_args = parser.add_argument_group(title="Optional Arguments")

    # Test arguments.
    tst_args = parser.add_mutually_exclusive_group(required=True)

    # Format arguments.
    fmt_args = parser.add_argument_group(title="Format Arguments")


    req_args.add_argument(
        '-H',
        '--host-file',
        type=str,
        help='A newline separated file of DNS-resolvable hostnames.',
    )
    req_args.add_argument(
        '-n',
        '--node',
        nargs='+',
        help='A space separate list of DNS-resolvable hostnames.',
    )

    tst_args.add_argument(
        '-i',
        '--icmp',
        action='store_true',
        help='ICMP Ping targets. Calls system ping utility.',
    )
    tst_args.add_argument(
        '-t',
        '--tcp',
        type=int,
        nargs=1,
        help='TCP ping targets. Accepts a numeric port.',
    )

    opt_args.add_argument(
        '-m',
        '--monitor',
        type=int,
        const=10,
        nargs='?',
        help='Monitor mode with a polling interval in seconds. Defaults to 10.',
    )

    fmt_args.add_argument(
        '-o',
        '--output-format',
        default='stdout',
        choices=['csv', 'json', 'stdout'],
        help='Write results to a file in CSV or JSON.'
    )

    return parser.parse_args()


def print_fmt(msg: str, level: str) -> str:
    # Print an ANSI color wrapped string.
    colors = {
        'debug': '\033[0;36m',
        'info': '\033[0;32m',
        'warn': '\033[1;33m',
        'error': '\033[1;31m',
        'fatal': '\033[0;31m',
        'reset': '\033[0m',
    }

    if level in colors.keys():
        print(f'{colors[level]}{msg}{colors["reset"]}', file=stderr)
    else:
        print(msg)


def read_file(file: str) -> list[str]:
    # Read a file. Return a list of strings.
    try:
        with open(file, 'r') as f:
            return f.read().splitlines()
    except Exception as e:
        print_fmt(f'Failed to read from {e.filename}: {e.strerror}', 'fatal')
        exit(e.errno)


def get_prog_path(prog: str) -> str:
    # Return an absolute path to a script or binary.
    return which(prog)


def get_os() -> str:
    # Return the OS family.
    return system()


def get_cores() -> int:
    # Return the number of CPU cores.
    return cpu_count()


def get_ip(node: NetObj) -> NetObj:
    # Perform a DNS lookup of a NetObj using the host DNS facility.
    if not check_ip(node.hostname):
        try:
            node.ip_addr = getaddrinfo(node.hostname, 80, family=AF_INET)[0][-1][0]
        except gaierror as e:
            node.errs = f'{e.errno}: {e.strerror}'
    else:
        node.ip_addr = node.hostname

    return node


def check_ip(ip_addr: str) -> bool:
    try:
        ip_address(ip_addr)
    except ValueError:
        return False

    return True


def check_ping(node: NetObj, base_cmd: list[str]) -> NetObj:
    # Ping check a NetObj.
    if node.ip_addr is None:
        node.status = 'unknown'
        return node

    if type(base_cmd) is tuple:
        base_cmd = base_cmd[0]

    cmd = base_cmd + [node.ip_addr]

    result = run(cmd, capture_output=True, encoding='UTF-8')
    node.outs = result.stdout.strip()
    node.errs = result.stderr.strip()

    if result.returncode != 0 or 'host unreachable' in node.errs.lower():
        node.status = 'dead'
    else:
        node.status = 'undead'

    node.return_code = result.returncode

    return node


def process_list(lst: list, func: Callable[...,...], procs: int, *args: Any) -> list:
    # Concurrently run a function on a list, using ThreadPoolExecutor.
    with ThreadPoolExecutor(max_workers=procs) as executor:
        if args:
            future_to_item = {executor.submit(func, item, args): item for item in lst}
        else:
            future_to_item = {executor.submit(func, item): item for item in lst}

        for future in as_completed(future_to_item):
            item = future_to_item[future]

            try:
                data = future.result()
            except Exception as e:
                print('%r generated an exception: %s' % (item, e))

    return lst


def write_output(nodes: list, fmt_args: dict) -> str:
    if fmt_args['fmt'].lower() == 'csv':
        f_name = fmt_args['f_name'] + f'.{fmt_args["fmt"]}'

        with open(f_name, 'w+') as f:
            writer = DictWriter(f, fieldnames = fmt_args['headers'])
            writer.writeheader()
            writer.writerows(
                {
                    k:v for k, v in node.__dict__.items() if k in fmt_args['headers']
                }
                for node in nodes
            )
    elif fmt_args['fmt'].lower() == 'json':
        f_name = fmt_args['f_name'] + f'.{fmt_args["fmt"]}'
        data = {'hosts': [node.__dict__ for node in nodes]}

        with open(f_name, 'w+') as f:
            dump(data, f)
    else:
        width = len(max([node.hostname for node in nodes], key=len)) + 5

        print(''.join(h.ljust(width) for h in fmt_args['headers']))
        for node in nodes:
            print(''.join([str(v).ljust(width) for k, v in node.__dict__.items() if k in fmt_args['headers']]))


def main():
    args = conf_args()
    def_cores = get_cores()

    if args.node:
        nodes = args.node
    elif args.host_file:
        nodes = read_file(args.host_file)
    else:
        print_fmt(f'DEBUG: No nodes specified. Argparse should have prevented this.', 'debug')
        exit(200)

    # Build a list of nodes as NetObj.
    nodes = [NetObj(node) for node in nodes]

    # Get node IP addresses.
    cores = def_cores * 20
    nodes = process_list(nodes, get_ip, cores)

    if args.icmp:
        ping = get_prog_path('ping')
        os = get_os()
        cores = def_cores * 20

        # Darwin and FreeBSD timeout is measured in milliseconds.
        # NetBSD doesn't support timeout, but does support deadline.

        # Linux usually measures timeout in seconds.
        if os in ['Darwin', 'FreeBSD']:
            base_cmd = [ping, '-c', '1', '-W', '1000']
        elif os in ['NetBSD', 'OpenBSD']:
            base_cmd = [ping, '-c', '1', '-w', '1']
        elif os == 'Windows':
            base_cmd = [ping, '/n', '1', '/w', '1000']
        else:
            base_cmd = [ping, '-c', '1', '-W', '1']

        # Ping nodes.
        nodes = process_list(nodes, check_ping, cores, base_cmd)

    # Write results, or print.
    fmt_args = {
        'f_name': f'undead_report_{datetime.now().strftime("%Y-%m-%d_%H%M%S")}',
        'headers': [
            'hostname',
            'ip_addr',
            'status',
            'return_code',
            'errs'
            ],
        'fmt': args.output_format,
    }

    write_output(nodes, fmt_args)


if __name__ == '__main__':
    exit(main())
